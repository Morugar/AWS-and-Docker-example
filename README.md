# **Testing & Production** using **Git**, **Docker** and **AWS**

### Самым первым я хочу подметить тот факт, что для использования Гита, Докера и AWS, нам нужно сначала установить эти самые инструменты. 

### У вас всегда есть два пути, по которым вы можете пойти:

### - Использовать терминал

### - Использовать UI инструменты

### Лично у меня терминал перекликается с VS Code, в котором есть множество удобных расширений для работы с Гитом и Докером, но вот расширение "AWS ToolKit" для AWS храмает и тут предпочтительнее использовать терминал.
--------
## Навигация
### - [Предисловие](#preface)
### - [Начало работы с Гитом](#git)
### - [Разбор нашего Dockerfile](#dockerfile)
### - [Сборка образа и запуск контейнера](#docker)
### - [Начало работы с AWS](#aws)
### - [Репозитории AWS](#aws-ecr)
### - [Запуск контейнера](#aws-ecs)
-------
## **Preface**
> Все махинации я проводил на Manjaro и Fedora => работоспособность на Windows не проверялась. 

> Я использую в примере маленькое web-приложение которое я написал на Flask, т.к. времени (и желания) разбираться, как работает Django у меня не было. Все сурсы лежат >[Здесь](https://github.com/Morugar/web_test "Ссылка на репозиторий с web-app'ом")<
--------

## **Git**

### В начале начал, нам нужна рабочая директория, куда мы будем клонировать наш репозиторий. В моём случае это будет папка `projects`.

### Создав директорию, мне нужно скопировать полный путь для неё.

### После этого нужно открыть терминал и ввестиd в него:
    cd <Путь до рабочей директории>

### Отлично, мы на месте. Теперь нам нужно склонировать наш репозиторий в эту папку. Для этого во всё том-же терминале вводим:

    git clone https://github.com/Morugar/web_test

### Теперь репозиторий с примером нашего web-приложения есть на нашем устройстве. 

-------

## **Dockerfile**

### Dockerfile - набор инструкций для Docker, которые он выполняет во время постройки изображения и запуска контейнера.

### В нашем случае Dockerfile имеет следующий вид:

    FROM python:3.9
    WORKDIR /usr/src/app
    COPY . .
    RUN pip install -r requirements.txt
    EXPOSE 8000
    CMD ["python", "./app.py"]

### Конкретно в нашем случае интересна строка `EXPOSE 8000`, которая указывает, на каком порте будет работать наш контейнер. Будет удобнее, если она будет совпадать с портом, который мы указываем в нашем Web-приложении. В моём случае порт как раз 8000.
--------

## **Docker**

### Теперь, когда у нас на руках есть готовый код и настроенный Dockerfile, мы можем создать из него образ и запустить его.

### Для сборки образа используем команду:

    docker build -t <Название Образа>:<Тег образа> <Путь до директории, где лежит Dockerfile>

### После успешной сборки, мы можем запустить наш контейнер используя:

    docker run -it --rm --name <Название контейнера> <Название образа>

### Отлично! Наш контейнер запущен и  аботает. Теперь мы можем перейти по адресу "http://127.0.0.1:8000/" и увидеть прекрасного щёнка!

----------

## **AWS**

### Для начала работы с AWS вам потребуется IAM аккаунт со всеми необходимыми правами. В нашем случае это права ECSFullAccess и ECRFullAccess

> Данные для работы с аккаунтом выдаются в виде .csv таблицы. В самом последнем столбце находиться `ссылка для входа в систему`. Первый и второй столбцы содержат `Логин` и `Пароль`, а Третий и Четвёртый содержат `Access Key` и `Private Access Key`

### Помимо прочего, вам нужен установленный AWS CLI на нашу систему. Его спокойно можно установить через любой пакетный менеджер (apt/dnf/pacman/pamac/yum)

----------
## **AWS ECR**

### AWS используют свою собственную систему репозиториев для работы с Докером, которая называется Elastic Container Registry

### Для запуска этого сервиса, в верхней строчке поиска наберите ECR и выберите соответствующий пункт.

> Сделаю помарку о том, что весь описанный ниже сценарий подходит для вариантов, когда вы работаете через IAM аккаунт, а не начинаете всё с нуля.

### Как только вы попадёте в ECR, вам нужно будет найти репозиторий `web`. Нажав на кликлабельное название, вы попадёте в список образов этого репозитория.

> Тут есть два выбора, как команда будет работать:
> 1. Иметь на каждого программиста собственный репозиторий
> 2. Иметь один репозиторий на проект, но разные теги образов.

> По поему личному ощущению второй пункт удобнее и практичнее, поэтому я буду рассматривать именно его.

### Теперь нам нужно авторизоваться в нашем AWS CLI, для этого нам нужно будет сначала ввести команду:

    aws configure 

### А после полной настройки, ввести в терминал команду:
    aws ecr get-login-password --region eu-north-1 | docker login --username AWS --password-stdin <ID вашего аккаунта>.dkr.ecr.eu-north-1.amazonaws.com
> Эту команду можно найти, если нажать на кнопку `View push commands` в обозревателе изображений репозитория.

> Именно где-то здесь на вашем пути могут встретиться ошибки и если вы такой-же криворукий как и я, то их будет много, чертовски много. Благо их решения спокойно гугляться, поэтому описывать их здесь я не буду. 

### Теперь нам нужно отметить общим тегом наш локальный образ и образ Амазона. Для этого используем команду:
    docker tag <Имя нащего образа>:<Данный нами ему тег> <Ваш ID>.dkr.ecr.eu-north-1.amazonaws.com/<Имя Репозитория>:<Нужный Тег>

### А теперь пушим наш образ на AWS:
    docker push <Наш ID>.dkr.ecr.eu-notrh-1.amazonaws.com/<Имя репозитория>:<Наш Тег>

### Теперь в нашем репозитории появился наш образ с нужным Тегом. Лично я использовал свой никнейм:

![avatar](https://i.imgur.com/JSAYZSn.png)

-------
## **AWS ECS**

### После успешного создания репозитория, нам нужно переключиться на новый сервис от Amazon, на Elastic Container Service (ECS)

### Сначала нам нужно создать Задание (Task) которое наш Кластер (Cluster) будет выполнять

### Переходим во вкладку `Task Definition` и нажимаем `Create new Task Definition`

### Выбираем тип запуска `Fargate`

### Вводим название, которое бы в полной мере олицетворяло суть задания. В моём случае я ввёл morugar-testing-task

### Краткая настройка:
### Operating system family - Linux
### Task execution IAM role - ecsTaskExecutionRole
### Task memory (GB) - 0.5 GB
### Task CPU (vCPU) - 0.25 vCPU

### Теперь нам нужно добавить контейнер, нажав на кнопку `Add container`

### Далее вводим имя нашего контейнера, а в поле `Image` мы вводим ссылку на наш образ из [ECR](#aws-ecr)

### В поле `Port mappings` вводим порт, который мы задали командой `EXPOSE` в `Dockerfile` (8000 в моём случае)

> `Memory Limits (MiB)` вводим значение необходимого нам объёма памяти для контейнера. В моём случае хватит 128 Мегабайт. 

### Теперь нам нужно создать Кластер.

### Нажимаем `Create new cluster`
### Тип Кластера выбираем `Fargate`
### Вводим название Кластера и нажимает `Create`
### Возвращаемся к `Task Definitions`и открываем наш таск.
### Ставим галочку около названия нашего таска и нужной нам версии (у меня это morugar-testing-task:1)
### Выбираем в поле `Actions` пункт `Run Task`
### Быстрые настройки:
### `Launch Type` - `FARGATE`
### `Operating system family` - `Linux`
### `Cluster` - Ранее созданный нами Кластер
### `Subnets` - выбираем любой пункт меню
### `Security groups` - Выбираем `Edit`. В открывшемся меню нажимаем `Add rule`. `Type` = `Custom NPC`;  
### `Port range` - Указываем порт, который использует наш контейнер (8000 в моём случае)
### Нажимаем `Save`
### Нажимаем `Run Task`
### Смотрим в колонке `Desired status` статус нашего таска.
### Теперь нажимаем на кликлабельное поле в столбце `Task`
### Ищем поле `Public IP` и копируем его содержимое.
### Открываем вкладку и вводим адрес вида <`Public IP`>:<`Port`>, у меня например получилось `13.53.37.146:8000`
### А теперь любуемся тому, какие мы молодцы!
----------------------------------------------------------------

## Где-то тут заканчивается документация о том, как запускать Docker Контейнеры на AWS
